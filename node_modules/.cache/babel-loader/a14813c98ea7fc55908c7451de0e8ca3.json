{"ast":null,"code":"'use strict';\n\nvar Messages = {\n  'accepted': 'The :attr must be accepted.',\n  // 'active_url'           : 'The :attr is not a valid URL.',\n  'after': 'The :attr must be a date after :date.',\n  'alpha': 'The :attr may only contain letters.',\n  'alpha_dash': 'The :attr may only contain letters, numbers, and dashes.',\n  'alpha_num': 'The :attr may only contain letters and numbers.',\n  'array': 'The :attr must be an array.',\n  'before': 'The :attr must be a date before :date.',\n  'between': {\n    'numeric': 'The :attr must be between :min and :max.',\n    'file': 'The :attr must be between :min and :max kilobytes.',\n    'string': 'The :attr must be between :min and :max characters.',\n    'array': 'The :attr must have between :min and :max items.'\n  },\n  'boolean': 'The :attr field must be true or false.',\n  'confirmed': 'The :attr confirmation does not match.',\n  'date': 'The :attr is not a valid date.',\n  'date_format': 'The :attr does not match the format :format.',\n  'different': 'The :attr and :other must be different.',\n  'digits': 'The :attr must be :digits digits.',\n  'digits_between': 'The :attr must be between :min and :max digits.',\n  'email': 'The :attr must be a valid email address.',\n  'exists': 'The selected :attr is invalid.',\n  'filled': 'The :attr field is required.',\n  'image': 'The :attr must be an image.',\n  'in': 'The selected :attr is invalid.',\n  'integer': 'The :attr must be an integer.',\n  'ip': 'The :attr must be a valid IP address.',\n  'json': 'The :attr must be a valid JSON string.',\n  'max': {\n    'numeric': 'The :attr may not be greater than :max.',\n    'file': 'The :attr may not be greater than :max kilobytes.',\n    'string': 'The :attr may not be greater than :max characters.',\n    'array': 'The :attr may not have more than :max items.'\n  },\n  'mimes': 'The :attr must be a file of type: :values.',\n  'min': {\n    'numeric': 'The :attr must be at least :min.',\n    'file': 'The :attr must be at least :min kilobytes.',\n    'string': 'The :attr must be at least :min characters.',\n    'array': 'The :attr must have at least :min items.'\n  },\n  'not_in': 'The selected :attr is invalid.',\n  'numeric': 'The :attr must be a number.',\n  'regex': 'The :attr format is invalid.',\n  'required': 'The :attr field is required.',\n  'required_if': 'The :attr field is required when :other is :value.',\n  'required_unless': 'The :attr field is required unless :other is in :values.',\n  'required_with': 'The :attr field is required when :values is present.',\n  'required_with_all': 'The :attr field is required when :values is present.',\n  'required_without': 'The :attr field is required when :values is not present.',\n  'required_without_all': 'The :attr field is required when none of :values are present.',\n  'same': 'The :attr and :other must match.',\n  'size': {\n    'numeric': 'The :attr must be :size.',\n    'file': 'The :attr must be :size kilobytes.',\n    'string': 'The :attr must be :size characters.',\n    'array': 'The :attr must contain :size items.'\n  },\n  'string': 'The :attr must be a string.',\n  // 'timezone'             : 'The :attr must be a valid zone.',\n  // 'unique'               : 'The :attr has already been taken.',\n  'url': 'The :attr format is invalid.'\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar Validator = function () {\n  function Validator(data, rules) {\n    var customMessages = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var customNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    classCallCheck(this, Validator);\n    this.data = data;\n    this.rules = this.parseRules(rules);\n    this.failedRules = [];\n    this.errors = null;\n    this.customRules = {};\n    this.customMessages = customMessages;\n    this.customNames = customNames;\n    this.customValues = {};\n  }\n\n  createClass(Validator, [{\n    key: 'extend',\n    value: function extend(ruleName, callback, customMessage) {\n      this.customRules[this.titleCase(ruleName)] = callback;\n\n      if (customMessage) {\n        this.customMessages[this.snakeCase(ruleName)] = customMessage;\n      }\n    }\n  }, {\n    key: 'parseRules',\n    value: function parseRules(rules) {\n      var self = this;\n      var arr = [];\n\n      for (var key in rules) {\n        arr.push({\n          name: key,\n          rules: self.parseItemRules(rules[key])\n        });\n      }\n\n      return arr;\n    }\n  }, {\n    key: 'parseItemRules',\n    value: function parseItemRules(itemRules) {\n      var self = this;\n      var rules = [];\n      itemRules.split('|').forEach(function (ruleAndArgs) {\n        if (ruleAndArgs.trim()) {\n          var args = ruleAndArgs.split(':');\n          rules.push({\n            name: self.titleCase(args[0], '_'),\n            params: args[1] ? args[1].split(',') : []\n          });\n        }\n      });\n      return rules;\n    }\n  }, {\n    key: 'titleCase',\n    value: function titleCase(str, delimiter) {\n      delimiter = delimiter || ' ';\n      return str.split(delimiter).map(function (item) {\n        return item[0].toUpperCase() + item.slice(1).toLowerCase();\n      }).join('');\n    }\n  }, {\n    key: 'snakeCase',\n    value: function snakeCase(str, delimiter) {\n      delimiter = delimiter || '_';\n      return str.replace(/((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))(?=[A-Z])/g, '$1' + delimiter).toLowerCase();\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue(name) {\n      if (typeof this.data[name] === 'undefined') {\n        return '';\n      }\n\n      return this.data[name];\n    }\n  }, {\n    key: 'isEmptyObject',\n    value: function isEmptyObject(obj) {\n      return Object.getOwnPropertyNames(obj).length === 0;\n    }\n  }, {\n    key: 'isImplicit',\n    value: function isImplicit(rule) {\n      return this.implicitRules.indexOf(rule) > -1;\n    }\n  }, {\n    key: 'hasData',\n    value: function hasData(name) {\n      return typeof this.data[name] !== 'undefined';\n    }\n  }, {\n    key: 'hasRule',\n    value: function hasRule(name, rules) {\n      return this.getRule(name, rules) !== null;\n    }\n  }, {\n    key: 'getRule',\n    value: function getRule(name, rulesToCheck) {\n      var a = this.rules.filter(function (item) {\n        return item.name === name;\n      });\n\n      if (a.length === 0) {\n        return null;\n      } else {\n        a = a[0];\n      }\n\n      if (!Array.isArray(rulesToCheck)) {\n        rulesToCheck = [rulesToCheck];\n      }\n\n      var b = a.rules.filter(function (rule) {\n        return rulesToCheck.indexOf(rule.name) >= 0;\n      });\n      return b.length === 0 ? null : [b[0].name, b[0].params];\n    }\n  }, {\n    key: 'requireParameterCount',\n    value: function requireParameterCount(count, params, rule) {\n      if (params.length < count) {\n        throw new Error('Validation rule ' + rule + ' requires at least ' + count + ' parameters');\n      }\n    }\n  }, {\n    key: 'passes',\n    value: function passes() {\n      var self = this;\n      this.errors = {};\n      this.failedRules = {};\n      this.rules.forEach(function (item) {\n        var name = item.name;\n        item.rules.forEach(function (rule) {\n          self.validate(name, rule);\n        });\n      });\n      return this.isEmptyObject(this.errors);\n    }\n  }, {\n    key: 'fails',\n    value: function fails() {\n      return !this.passes();\n    }\n  }, {\n    key: 'valid',\n    value: function valid() {\n      if (this.errors === null) {\n        this.passes();\n      }\n\n      var arr = [];\n\n      for (var key in this.data) {\n        if (!this.hasError(key)) {\n          arr.push(key);\n        }\n      }\n\n      return arr;\n    }\n  }, {\n    key: 'invalid',\n    value: function invalid() {\n      if (this.errors === null) {\n        this.passes();\n      }\n\n      var arr = [];\n\n      for (var key in this.errors) {\n        arr.push(key);\n      }\n\n      return arr;\n    }\n  }, {\n    key: 'getErrorMsg',\n    value: function getErrorMsg(name, rule) {\n      var msg = this.getMessage(name, rule);\n      return this.doReplacements(msg, name, rule);\n    }\n  }, {\n    key: 'getMessage',\n    value: function getMessage(name, rule) {\n      // 1) return custom message if defined\n      var msg = this.getCustomMessage(name, rule);\n\n      if ((typeof msg === 'undefined' ? 'undefined' : _typeof(msg)) !== 'object' && typeof msg !== 'undefined') {\n        return msg;\n      }\n\n      var key = this.snakeCase(rule.name); // 2) then, use the default message for that rule, and re-test\n\n      msg = Messages[key]; // 3) check if the message has subtype\n\n      if ((typeof msg === 'undefined' ? 'undefined' : _typeof(msg)) === 'object') {\n        var subtype = this.getDataType(name);\n        msg = Messages[key][subtype];\n      }\n\n      return typeof msg === 'undefined' ? '' : msg;\n    }\n    /**\n     * return user-defined custom message for a given rule, or undefined\n     */\n\n  }, {\n    key: 'getCustomMessage',\n    value: function getCustomMessage(name, rule) {\n      var ruleName = this.snakeCase(rule.name);\n      var msg = this.customMessages[name + '.' + ruleName]; // first, check for custom message for specific attribute rule\n      // then, check for custom message for rule\n\n      return typeof msg === 'undefined' ? this.customMessages[ruleName] : msg;\n    }\n  }, {\n    key: 'getDataType',\n    value: function getDataType(name) {\n      if (this.hasRule(name, this.numericRules)) {\n        return 'numeric';\n      } else if (this.hasRule(name, ['Array'])) {\n        return 'array';\n      }\n      /* SKIP file type */\n\n\n      return 'string';\n    }\n  }, {\n    key: 'doReplacements',\n    value: function doReplacements(msg, name, rule) {\n      if (msg.trim() === '') {\n        return '';\n      }\n\n      name = this.getDataName(name);\n      msg = msg.replace(':ATTR', name.toUpperCase()).replace(':Attr', this.titleCase(name)).replace(':attr', name); // call replacer\n\n      var replacer = this['replace' + rule.name];\n\n      if (typeof replacer === 'function') {\n        msg = replacer.apply(this, [msg, name, rule.name, rule.params]);\n      }\n\n      return msg;\n    }\n  }, {\n    key: 'validate',\n    value: function validate(name, rule) {\n      var value = this.getValue(name);\n      var method = this.findRuleMethod(rule); // return method.apply(this, [name, value, rule.params])\n\n      if (!method.apply(this, [name, value, rule.params])) {\n        this.addFailure(name, rule);\n      }\n    }\n  }, {\n    key: 'findRuleMethod',\n    value: function findRuleMethod(rule) {\n      var method = this['validate' + rule.name];\n\n      if (!method) {\n        method = this.customRules[rule.name];\n      }\n\n      if (typeof method !== 'function') {\n        console.error('\"' + rule.name + '\" validation rule does not exist!');\n      }\n\n      return method;\n    }\n    /*\n        isValidatable(rule, name, value) {\n            return this.presentOrRuleIsImplicit(rule, name, value) &&\n                   this.passesOptionalCheck(name) &&\n                   this.hasNotFailedPreviousRuleIfPresenceRule(rule, name)\n        }\n    \n        presentOrRuleIsImplicit(rule, name, value) {\n            return this.validateRequired(name, value) || this.isImplicit(rule)\n        }\n    \n        passesOptionalCheck(name) {\n            return true\n        }\n    \n        hasNotFailedPreviousRuleIfPresenceRule(rule, name) {\n            return true\n        }\n    */\n\n  }, {\n    key: 'addFailure',\n    value: function addFailure(name, rule) {\n      this.addError(name, rule);\n\n      if (typeof this.failedRules[name] === 'undefined') {\n        this.failedRules[name] = {};\n      }\n\n      this.failedRules[name][rule.name] = rule.params;\n    }\n  }, {\n    key: 'addError',\n    value: function addError(name, rule) {\n      var msg = this.getMessage(name, rule);\n\n      if ((typeof msg === 'undefined' ? 'undefined' : _typeof(msg)) === 'object') {\n        console.log('***** ', JSON.stringify(rule), JSON.stringify(msg));\n      }\n\n      msg = this.doReplacements(msg, name, rule);\n\n      if (!this.hasError(name)) {\n        this.errors[name] = [];\n      }\n\n      this.errors[name].push(msg);\n    }\n  }, {\n    key: 'hasError',\n    value: function hasError() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (name === null) {\n        return !this.isEmptyObject(this.errors);\n      }\n\n      return this.getError(name) === null ? false : true;\n    }\n  }, {\n    key: 'getError',\n    value: function getError(name) {\n      return typeof this.errors[name] === 'undefined' ? null : this.errors[name];\n    }\n  }, {\n    key: 'getErrors',\n    value: function getErrors() {\n      return this.errors;\n    }\n    /** Validation Rules **/\n\n  }, {\n    key: 'validateSometimes',\n    value: function validateSometimes() {\n      return true;\n    }\n  }, {\n    key: 'validateBail',\n    value: function validateBail() {\n      return true;\n    }\n  }, {\n    key: 'shouldStopValidating',\n    value: function shouldStopValidating(name) {\n      if (!this.hasRule(name, ['Bail'])) {\n        return false;\n      }\n\n      return this.hasError(name);\n    }\n  }, {\n    key: 'validateRequired',\n    value: function validateRequired(name, value, params) {\n      if (value === null) {\n        return false;\n      } else if (typeof value === 'string' && value.trim() === '') {\n        return false;\n      } else if (Array.isArray(value) && value.length < 1) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'validatePresent',\n    value: function validatePresent(name, value, params) {\n      return typeof this.data[name] !== 'undefined';\n    }\n  }, {\n    key: 'validateFilled',\n    value: function validateFilled(name, value) {\n      if (this.hasData(name)) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'anyFailingRequired',\n    value: function anyFailingRequired(names) {\n      var self = this;\n      var result = false;\n      names.forEach(function (name) {\n        if (!self.validateRequired(name, self.getValue(name))) {\n          result = true;\n          return;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: 'allFailingRequired',\n    value: function allFailingRequired(names) {\n      var self = this;\n      var result = true;\n      names.forEach(function (name) {\n        if (self.validateRequired(name, self.getValue(name))) {\n          result = false;\n          return;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: 'validateRequiredWith',\n    value: function validateRequiredWith(name, value, params) {\n      if (!this.allFailingRequired(params)) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'validateRequiredWithAll',\n    value: function validateRequiredWithAll(name, value, params) {\n      if (!this.anyFailingRequired(params)) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'validateRequiredWithout',\n    value: function validateRequiredWithout(name, value, params) {\n      if (this.anyFailingRequired(params)) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'validateRequiredWithoutAll',\n    value: function validateRequiredWithoutAll(name, value, params) {\n      if (this.allFailingRequired(params)) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'validateRequiredIf',\n    value: function validateRequiredIf(name, value, params) {\n      this.requireParameterCount(2, params, 'required_if');\n      var data = this.getValue(params[0]);\n\n      if (typeof data === 'boolean') {\n        data = data.toString();\n      }\n\n      var values = params.slice(1);\n\n      if (values.indexOf(data) >= 0) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'validateRequiredUnless',\n    value: function validateRequiredUnless(name, value, params) {\n      this.requireParameterCount(2, params, 'required_unless');\n      var data = this.getValue(params[0]);\n      var values = params.slice(1);\n\n      if (values.indexOf(data) < 0) {\n        return this.validateRequired(name, value);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'getPresentCount',\n    value: function getPresentCount(names) {\n      var self = this;\n      var count = 0;\n      names.forEach(function (name) {\n        if (typeof self.data[name] !== 'undefined') {\n          count++;\n        }\n      });\n      return count;\n    }\n  }, {\n    key: 'validateMatch',\n    value: function validateMatch(name, value, params) {\n      if (!(params instanceof Array)) {\n        params = [params];\n      }\n\n      if (!(value instanceof Array)) {\n        value = [value];\n      }\n\n      var re = params[0];\n\n      if (!(re instanceof RegExp)) {\n        re = re.split('/');\n        re = new RegExp(re[1], re[2]);\n      }\n\n      return re.test(value);\n    }\n  }, {\n    key: 'validateRegex',\n    value: function validateRegex(name, value, params) {\n      return this.validateMatch(name, value, params);\n    }\n  }, {\n    key: 'validateAccepted',\n    value: function validateAccepted(name, value) {\n      var acceptable = ['yes', 'on', '1', 1, true, 'true'];\n      return this.validateRequired(name, value) && acceptable.indexOf(value) >= 0;\n    }\n  }, {\n    key: 'validateArray',\n    value: function validateArray(name, value) {\n      if (typeof this.data[name] === 'undefined') {\n        return true;\n      }\n\n      return value === null || Array.isArray(value);\n    }\n  }, {\n    key: 'validateConfirmed',\n    value: function validateConfirmed(name, value) {\n      return this.validateSame(name, value, [name + '_confirmation']);\n    }\n  }, {\n    key: 'validateSame',\n    value: function validateSame(name, value, params) {\n      this.requireParameterCount(1, params, 'same');\n      var other = this.data[params[0]];\n      return typeof other !== 'undefined' && value === other;\n    }\n  }, {\n    key: 'validateDifferent',\n    value: function validateDifferent(name, value, params) {\n      this.requireParameterCount(1, params, 'different');\n      var other = this.data[params[0]];\n      return typeof other !== 'undefined' && value !== other;\n    }\n  }, {\n    key: 'validateDigits',\n    value: function validateDigits(name, value, params) {\n      this.requireParameterCount(1, params, 'digits');\n      return this.validateNumeric(name, value) && value.toString().length == params[0];\n    }\n  }, {\n    key: 'validateDigitsBetween',\n    value: function validateDigitsBetween(name, value, params) {\n      this.requireParameterCount(2, params, 'digits_between');\n      var len = value.toString().length;\n      return this.validateNumeric(name, value) && len >= params[0] && len <= params[1];\n    }\n  }, {\n    key: 'validateSize',\n    value: function validateSize(name, value, params) {\n      this.requireParameterCount(1, params, 'size');\n      return this.getSize(name, value) == params[0];\n    }\n  }, {\n    key: 'validateBetween',\n    value: function validateBetween(name, value, params) {\n      this.requireParameterCount(2, params, 'between');\n      var size = this.getSize(name, value);\n      return size >= params[0] && size <= params[1];\n    }\n  }, {\n    key: 'validateMin',\n    value: function validateMin(name, value, params) {\n      this.requireParameterCount(1, params, 'min');\n      return this.getSize(name, value) >= params[0];\n    }\n  }, {\n    key: 'validateMax',\n    value: function validateMax(name, value, params) {\n      this.requireParameterCount(1, params, 'max');\n      return this.getSize(name, value) <= params[0];\n    }\n  }, {\n    key: 'getSize',\n    value: function getSize(name, value) {\n      var hasNumeric = this.hasRule(name, this.numericRules);\n\n      if (hasNumeric && !isNaN(parseFloat(value))) {\n        return parseFloat(value);\n      } // for array and string\n\n\n      return value.length;\n    }\n  }, {\n    key: 'validateIn',\n    value: function validateIn(name, value, params) {\n      if (Array.isArray(value) && this.hasRule(name, 'Array')) {\n        var arr = this.arrayDiff(value, params);\n        return arr.length === 0;\n      }\n\n      return params.indexOf(value) >= 0;\n    }\n  }, {\n    key: 'arrayDiff',\n    value: function arrayDiff(arr1, arr2) {\n      var diff = [];\n      arr1.forEach(function (item) {\n        if (arr2.indexOf(item) < 0) {\n          diff.push(item);\n        }\n      });\n      return diff;\n    }\n  }, {\n    key: 'validateNotIn',\n    value: function validateNotIn(name, value, params) {\n      this.requireParameterCount(1, params, 'not_in');\n      return !this.validateIn(name, value, params);\n    }\n  }, {\n    key: 'validateNumeric',\n    value: function validateNumeric(name, value) {\n      return this.validateMatch(name, value, /^-?\\d+(\\.\\d*)?$/);\n    }\n  }, {\n    key: 'validateInteger',\n    value: function validateInteger(name, value) {\n      return this.validateMatch(name, value, /^-?\\d+$/);\n    }\n  }, {\n    key: 'validateString',\n    value: function validateString(name, value) {\n      if (!this.hasData(name)) {\n        return true;\n      }\n\n      return value === null || typeof value === 'string';\n    }\n  }, {\n    key: 'validateEmail',\n    value: function validateEmail(name, value) {\n      return this.validateMatch(name, value, /^[A-Z0-9._%+\\-]+@[A-Z0-9.\\-]+\\.[A-Z]{2,4}$/i);\n    }\n  }, {\n    key: 'validateIp',\n    value: function validateIp(name, value) {\n      var segments = value.split('.');\n\n      if (segments.length === 4 && this.validateBetween(name, segments[0], [1, 255]) && this.validateBetween(name, segments[1], [0, 255]) && this.validateBetween(name, segments[2], [0, 255]) && this.validateBetween(name, segments[3], [1, 255])) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'validateUrl',\n    value: function validateUrl(name, value) {\n      return this.validateMatch(name, value, /^(https?|ftp):\\/\\/[^\\s\\/$.?#].[^\\s]*$/i);\n    }\n  }, {\n    key: 'validateAlpha',\n    value: function validateAlpha(name, value) {\n      return this.validateMatch(name, value, /^([a-z])+$/i);\n    }\n  }, {\n    key: 'validateAlphaNum',\n    value: function validateAlphaNum(name, value) {\n      return this.validateMatch(name, value, /^([a-z0-9])+$/i);\n    }\n  }, {\n    key: 'validateAlphaDash',\n    value: function validateAlphaDash(name, value) {\n      return this.validateMatch(name, value, /^([a-z0-9_\\-])+$/i);\n    }\n  }, {\n    key: 'validateBefore',\n    value: function validateBefore(name, value, params) {\n      this.requireParameterCount(1, params, 'before');\n\n      if (typeof value !== 'string' && typeof value !== 'number' && !(value instanceof Date)) {\n        return false;\n      }\n\n      var date = this.hasData(params[0]) ? this.getValue(params[0]) : params[0];\n\n      if (!this.validateDate(name, date)) {\n        console.error(params[0] + ' does not appear to be a date.');\n        return false;\n      }\n\n      return Date.parse(value) < Date.parse(date);\n    }\n  }, {\n    key: 'validateAfter',\n    value: function validateAfter(name, value, params) {\n      this.requireParameterCount(1, params, 'after');\n\n      if (typeof value !== 'string' && typeof value !== 'number' && !(value instanceof Date)) {\n        return false;\n      }\n\n      var date = this.hasData(params[0]) ? this.getValue(params[0]) : params[0];\n\n      if (!this.validateDate(name, date)) {\n        console.error(params[0] + ' does not appear to be a date.');\n        return false;\n      }\n\n      return Date.parse(value) > Date.parse(date);\n    }\n  }, {\n    key: 'validateDate',\n    value: function validateDate(name, value) {\n      if (value instanceof Date) {\n        return true;\n      }\n\n      if (typeof value !== 'string' && typeof value !== 'number') {\n        return false;\n      }\n\n      return !isNaN(Date.parse(value));\n    }\n  }, {\n    key: 'validateBoolean',\n    value: function validateBoolean(name, value) {\n      if (!this.hasData(name)) {\n        return true;\n      }\n\n      var acceptable = [true, false, 0, 1, '0', '1'];\n      return value === null || acceptable.indexOf(value) >= 0;\n    }\n  }, {\n    key: 'validateJson',\n    value: function validateJson(name, value) {\n      try {\n        JSON.parse(value);\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    /*---- Replacers ----*/\n\n  }, {\n    key: 'strReplace',\n    value: function strReplace(find, replace, string) {\n      if (!Array.isArray(find)) {\n        find = [find];\n      }\n\n      if (!Array.isArray(replace)) {\n        replace = [replace];\n      }\n\n      for (var i = 0; i < find.length; i++) {\n        string = string.replace(find[i], replace[i]);\n      }\n\n      return string;\n    }\n  }, {\n    key: 'getDisplayableValue',\n    value: function getDisplayableValue(name, value) {\n      if (typeof this.customValues[name] !== 'undefined' && typeof this.customValues[name][value] !== 'undefined') {\n        return this.customValues[name][value];\n      }\n\n      return value;\n    } // getAttributeList\n\n  }, {\n    key: 'getDataNameList',\n    value: function getDataNameList(values) {\n      var names = [];\n\n      for (var key in values) {\n        names.push({\n          key: this.getDataName(values[key])\n        });\n      }\n\n      return names;\n    } // getAttribute\n\n  }, {\n    key: 'getDataName',\n    value: function getDataName(name) {\n      if (typeof this.customNames[name] !== 'undefined') {\n        return this.customNames[name];\n      }\n\n      return this.strReplace('_', ' ', this.snakeCase(name));\n    } // setAttributeNames\n\n  }, {\n    key: 'setCustomNames',\n    value: function setCustomNames(names) {\n      this.customNames = names;\n      return this;\n    }\n  }, {\n    key: 'addCustomNames',\n    value: function addCustomNames(customNames) {\n      for (var key in customNames) {\n        this.customNames[key] = customNames[key];\n      }\n\n      return this;\n    }\n  }, {\n    key: 'getCustomValues',\n    value: function getCustomValues() {\n      return this.customValues;\n    }\n  }, {\n    key: 'addCustomValues',\n    value: function addCustomValues(customValues) {\n      for (var key in customValues) {\n        this.customValues[key] = customValues[key];\n      }\n\n      return this;\n    }\n  }, {\n    key: 'setValueNames',\n    value: function setValueNames(values) {\n      this.customValues = values;\n      return this;\n    }\n  }, {\n    key: 'failed',\n    value: function failed() {\n      return this.failedRules;\n    }\n  }, {\n    key: 'replaceBetween',\n    value: function replaceBetween(msg, name, rule, params) {\n      return this.strReplace([':min', ':max'], params, msg);\n    }\n  }, {\n    key: 'replaceDifferent',\n    value: function replaceDifferent(msg, name, rule, params) {\n      return this.replaceSame(msg, name, rule, params);\n    }\n  }, {\n    key: 'replaceDigits',\n    value: function replaceDigits(msg, name, rule, params) {\n      return this.strReplace(':digits', params[0], msg);\n    }\n  }, {\n    key: 'replaceDigitsBetween',\n    value: function replaceDigitsBetween(msg, name, rule, params) {\n      return this.replaceBetween(msg, name, rule, params);\n    }\n  }, {\n    key: 'replaceMin',\n    value: function replaceMin(msg, name, rule, params) {\n      return this.strReplace(':min', params[0], msg);\n    }\n  }, {\n    key: 'replaceMax',\n    value: function replaceMax(msg, name, rule, params) {\n      return this.strReplace(':max', params[0], msg);\n    }\n  }, {\n    key: 'replaceIn',\n    value: function replaceIn(msg, name, rule, params) {\n      var self = this;\n      params = params.map(function (value) {\n        return self.getDisplayableValue(name, value);\n      });\n      return this.strReplace(':values', params.join(', '), msg);\n    }\n  }, {\n    key: 'replaceNotIn',\n    value: function replaceNotIn(msg, name, rule, params) {\n      return this.replaceIn(msg, name, rule, params);\n    } // replaceInArray()\n    // replaceMimes()\n\n  }, {\n    key: 'replaceRequiredWith',\n    value: function replaceRequiredWith(msg, name, rule, params) {\n      params = this.getDataNameList(params);\n      return this.strReplace(':values', params.join(' / '), msg);\n    }\n  }, {\n    key: 'replaceRequiredWithAll',\n    value: function replaceRequiredWithAll(msg, name, rule, params) {\n      return this.replaceRequiredWith(msg, name, rule, params);\n    }\n  }, {\n    key: 'replaceRequiredWithout',\n    value: function replaceRequiredWithout(msg, name, rule, params) {\n      return this.replaceRequiredWith(msg, name, rule, params);\n    }\n  }, {\n    key: 'replaceRequiredWithoutAll',\n    value: function replaceRequiredWithoutAll(msg, name, rule, params) {\n      return this.replaceRequiredWith(msg, name, rule, params);\n    }\n  }, {\n    key: 'replaceRequiredIf',\n    value: function replaceRequiredIf(msg, name, rule, params) {\n      params[1] = this.getDisplayableValue(params[0], this.data[params[0]]);\n      params[0] = this.getDataName(params[0]);\n      return this.strReplace([':other', ':value'], params, msg);\n    }\n  }, {\n    key: 'replaceRequiredUnless',\n    value: function replaceRequiredUnless(msg, name, rule, params) {\n      var other = this.getDataName(params.shift());\n      return this.strReplace([':other', ':values'], [other, params.join(', ')], msg);\n    }\n  }, {\n    key: 'replaceSame',\n    value: function replaceSame(msg, name, rule, params) {\n      return this.strReplace(':other', name, msg);\n    }\n  }, {\n    key: 'replaceSize',\n    value: function replaceSize(msg, name, rule, params) {\n      return this.strReplace(':size', params[0], msg);\n    }\n  }, {\n    key: 'replaceBefore',\n    value: function replaceBefore(msg, name, rule, params) {\n      if (isNaN(Date.parse(params[0]))) {\n        return this.strReplace(':date', this.getDataName(params[0]), msg);\n      }\n\n      return this.strReplace(':date', params[0], msg);\n    }\n  }, {\n    key: 'replaceAfter',\n    value: function replaceAfter(msg, name, rule, params) {\n      return this.replaceBefore(msg, name, rule, params);\n    }\n  }, {\n    key: 'dependsOnOtherFields',\n    value: function dependsOnOtherFields(rule) {\n      return this.dependentRules.indexOf(rule);\n    }\n  }, {\n    key: 'dateRules',\n    get: function get$$1() {\n      return ['Before', 'After', 'DateBetween'];\n    }\n  }, {\n    key: 'sizeRules',\n    get: function get$$1() {\n      return ['Size', 'Between', 'Min', 'Max'];\n    }\n  }, {\n    key: 'numericRules',\n    get: function get$$1() {\n      return ['Numeric', 'Integer'];\n    }\n  }, {\n    key: 'implicitRules',\n    get: function get$$1() {\n      return ['Required', 'Filled', 'RequiredWith', 'RequiredWithAll', 'RequiredWithout', 'RequiredWithoutAll', 'RequiredIf', 'RequiredUnless', 'Accepted', 'Present'];\n    }\n  }, {\n    key: 'dependentRules',\n    get: function get$$1() {\n      return ['RequiredWith', 'RequiredWithAll', 'RequiredWithout', 'RequiredWithoutAll', 'RequiredIf', 'RequiredUnless', 'Confirmed', 'Same', 'Different', 'Unique', 'Before', 'After'];\n    }\n  }], [{\n    key: 'make',\n    value: function make(data, rules) {\n      var customMessages = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var customNames = arguments[3];\n      return new Validator(data, rules, customMessages, customNames);\n    }\n  }]);\n  return Validator;\n}();\n\nmodule.exports = Validator;","map":null,"metadata":{},"sourceType":"script"}